import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken } from './lib/auth';

// Routes publiques (accessibles sans authentification)
const publicRoutes = [
  '/',
  '/login',
  '/register',
  '/mot-passe-oublie',
  '/reservation',
  '/services',
  '/tarifs',
  '/contact',
  '/about',
  '/api/auth/login',
  '/api/auth/register',
  '/api/services',
];

// Configuration des accès par rôle
const roleAccess = {
  ADMIN: ['/admin', '/api/admin', '/api/users', '/api/stats'],
  COMPTABLE: ['/admin/finances', '/admin/stats', '/admin/comptabilite', '/api/stats', '/api/finances'],
  EMPLOYEE: ['/admin/planning', '/admin/clients', '/admin/reservations', '/api/reservations', '/api/clients'],
  STAGIAIRE: ['/admin/planning', '/api/reservations/view'],
  CLIENT: ['/espace-client', '/api/user', '/api/reservations/mine'],
};

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Permettre l'accès aux ressources statiques
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/static') ||
    pathname.includes('.') // fichiers avec extension (.js, .css, .png, etc.)
  ) {
    return NextResponse.next();
  }

  // Vérifier si c'est une route publique
  const isPublicRoute = publicRoutes.some(route => 
    pathname === route || pathname.startsWith(route + '/')
  );
  
  if (isPublicRoute) {
    return NextResponse.next();
  }

  // Récupérer le token depuis les cookies ou l'en-tête Authorization
  const token = request.cookies.get('token')?.value || 
                request.headers.get('authorization')?.replace('Bearer ', '');

  if (!token) {
    // Rediriger vers login si pas de token
    if (pathname.startsWith('/api/')) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }
    return NextResponse.redirect(new URL('/login', request.url));
  }

  try {
    // Vérifier et décoder le token
    const decoded = await verifyToken(token) as { userId: string; role: string };
    
    if (!decoded) {
      throw new Error('Token invalide');
    }

    // Vérifier les permissions selon le rôle
    const userRole = decoded.role.toUpperCase();
    
    // Admin a accès à tout
    if (userRole === 'ADMIN') {
      const response = NextResponse.next();
      response.headers.set('x-user-role', userRole);
      response.headers.set('x-user-id', decoded.userId);
      return response;
    }

    // Vérifier l'accès selon le rôle
    let hasAccess = false;
    
    // Vérifier l'accès aux routes spécifiques du rôle
    if (roleAccess[userRole as keyof typeof roleAccess]) {
      hasAccess = roleAccess[userRole as keyof typeof roleAccess].some(route => 
        pathname.startsWith(route)
      );
    }

    // Routes spéciales pour l'espace client
    if (userRole === 'CLIENT' && pathname.startsWith('/espace-client')) {
      hasAccess = true;
    }

    // Routes communes à tous les utilisateurs connectés
    const commonAuthRoutes = ['/profile', '/api/auth/logout', '/api/auth/me'];
    if (commonAuthRoutes.some(route => pathname.startsWith(route))) {
      hasAccess = true;
    }

    if (!hasAccess) {
      // Log de tentative d'accès non autorisé
      console.warn(`⚠️ Accès refusé : ${userRole} tentant d'accéder à ${pathname}`);
      
      if (pathname.startsWith('/api/')) {
        return NextResponse.json({ error: 'Accès refusé' }, { status: 403 });
      }
      
      // Rediriger selon le rôle
      const redirectMap = {
        CLIENT: '/espace-client',
        COMPTABLE: '/admin/finances',
        EMPLOYEE: '/admin/planning',
        STAGIAIRE: '/admin/planning',
      };
      
      const redirectPath = redirectMap[userRole as keyof typeof redirectMap] || '/';
      return NextResponse.redirect(new URL(redirectPath, request.url));
    }

    // Ajouter les informations utilisateur aux headers pour les routes autorisées
    const response = NextResponse.next();
    response.headers.set('x-user-role', userRole);
    response.headers.set('x-user-id', decoded.userId);
    
    return response;

  } catch (error) {
    console.error('Erreur middleware auth:', error);
    
    // Token invalide ou expiré
    if (pathname.startsWith('/api/')) {
      return NextResponse.json({ error: 'Session expirée' }, { status: 401 });
    }
    
    // Supprimer le cookie invalide et rediriger vers login
    const response = NextResponse.redirect(new URL('/login', request.url));
    response.cookies.delete('token');
    return response;
  }
}

// Configuration des routes où le middleware s'applique
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|public).*)',
  ],
};